
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// @ts-nocheck 
/**
 * This file exports the `UserCity` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import * as runtime from "@prisma/client/runtime/library"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model UserCity
 * 
 */
export type UserCityModel = runtime.Types.Result.DefaultSelection<Prisma.$UserCityPayload>

export type AggregateUserCity = {
  _count: UserCityCountAggregateOutputType | null
  _min: UserCityMinAggregateOutputType | null
  _max: UserCityMaxAggregateOutputType | null
}

export type UserCityMinAggregateOutputType = {
  userId: string | null
  cityId: string | null
  role: $Enums.UserCityRole | null
}

export type UserCityMaxAggregateOutputType = {
  userId: string | null
  cityId: string | null
  role: $Enums.UserCityRole | null
}

export type UserCityCountAggregateOutputType = {
  userId: number
  cityId: number
  role: number
  _all: number
}


export type UserCityMinAggregateInputType = {
  userId?: true
  cityId?: true
  role?: true
}

export type UserCityMaxAggregateInputType = {
  userId?: true
  cityId?: true
  role?: true
}

export type UserCityCountAggregateInputType = {
  userId?: true
  cityId?: true
  role?: true
  _all?: true
}

export type UserCityAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which UserCity to aggregate.
   */
  where?: Prisma.UserCityWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of UserCities to fetch.
   */
  orderBy?: Prisma.UserCityOrderByWithRelationInput | Prisma.UserCityOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.UserCityWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` UserCities from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` UserCities.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned UserCities
  **/
  _count?: true | UserCityCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: UserCityMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: UserCityMaxAggregateInputType
}

export type GetUserCityAggregateType<T extends UserCityAggregateArgs> = {
      [P in keyof T & keyof AggregateUserCity]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateUserCity[P]>
    : Prisma.GetScalarType<T[P], AggregateUserCity[P]>
}




export type UserCityGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.UserCityWhereInput
  orderBy?: Prisma.UserCityOrderByWithAggregationInput | Prisma.UserCityOrderByWithAggregationInput[]
  by: Prisma.UserCityScalarFieldEnum[] | Prisma.UserCityScalarFieldEnum
  having?: Prisma.UserCityScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: UserCityCountAggregateInputType | true
  _min?: UserCityMinAggregateInputType
  _max?: UserCityMaxAggregateInputType
}

export type UserCityGroupByOutputType = {
  userId: string
  cityId: string
  role: $Enums.UserCityRole
  _count: UserCityCountAggregateOutputType | null
  _min: UserCityMinAggregateOutputType | null
  _max: UserCityMaxAggregateOutputType | null
}

type GetUserCityGroupByPayload<T extends UserCityGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<UserCityGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof UserCityGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], UserCityGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], UserCityGroupByOutputType[P]>
      }
    >
  >



export type UserCityWhereInput = {
  AND?: Prisma.UserCityWhereInput | Prisma.UserCityWhereInput[]
  OR?: Prisma.UserCityWhereInput[]
  NOT?: Prisma.UserCityWhereInput | Prisma.UserCityWhereInput[]
  userId?: Prisma.StringFilter<"UserCity"> | string
  cityId?: Prisma.StringFilter<"UserCity"> | string
  role?: Prisma.EnumUserCityRoleFilter<"UserCity"> | $Enums.UserCityRole
  user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
  city?: Prisma.XOR<Prisma.CityScalarRelationFilter, Prisma.CityWhereInput>
}

export type UserCityOrderByWithRelationInput = {
  userId?: Prisma.SortOrder
  cityId?: Prisma.SortOrder
  role?: Prisma.SortOrder
  user?: Prisma.UserOrderByWithRelationInput
  city?: Prisma.CityOrderByWithRelationInput
  _relevance?: Prisma.UserCityOrderByRelevanceInput
}

export type UserCityWhereUniqueInput = Prisma.AtLeast<{
  userId_cityId?: Prisma.UserCityUserIdCityIdCompoundUniqueInput
  AND?: Prisma.UserCityWhereInput | Prisma.UserCityWhereInput[]
  OR?: Prisma.UserCityWhereInput[]
  NOT?: Prisma.UserCityWhereInput | Prisma.UserCityWhereInput[]
  userId?: Prisma.StringFilter<"UserCity"> | string
  cityId?: Prisma.StringFilter<"UserCity"> | string
  role?: Prisma.EnumUserCityRoleFilter<"UserCity"> | $Enums.UserCityRole
  user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
  city?: Prisma.XOR<Prisma.CityScalarRelationFilter, Prisma.CityWhereInput>
}, "userId_cityId">

export type UserCityOrderByWithAggregationInput = {
  userId?: Prisma.SortOrder
  cityId?: Prisma.SortOrder
  role?: Prisma.SortOrder
  _count?: Prisma.UserCityCountOrderByAggregateInput
  _max?: Prisma.UserCityMaxOrderByAggregateInput
  _min?: Prisma.UserCityMinOrderByAggregateInput
}

export type UserCityScalarWhereWithAggregatesInput = {
  AND?: Prisma.UserCityScalarWhereWithAggregatesInput | Prisma.UserCityScalarWhereWithAggregatesInput[]
  OR?: Prisma.UserCityScalarWhereWithAggregatesInput[]
  NOT?: Prisma.UserCityScalarWhereWithAggregatesInput | Prisma.UserCityScalarWhereWithAggregatesInput[]
  userId?: Prisma.StringWithAggregatesFilter<"UserCity"> | string
  cityId?: Prisma.StringWithAggregatesFilter<"UserCity"> | string
  role?: Prisma.EnumUserCityRoleWithAggregatesFilter<"UserCity"> | $Enums.UserCityRole
}

export type UserCityCreateInput = {
  role: $Enums.UserCityRole
  user: Prisma.UserCreateNestedOneWithoutCitiesInput
  city: Prisma.CityCreateNestedOneWithoutUserCityInput
}

export type UserCityUncheckedCreateInput = {
  userId: string
  cityId: string
  role: $Enums.UserCityRole
}

export type UserCityUpdateInput = {
  role?: Prisma.EnumUserCityRoleFieldUpdateOperationsInput | $Enums.UserCityRole
  user?: Prisma.UserUpdateOneRequiredWithoutCitiesNestedInput
  city?: Prisma.CityUpdateOneRequiredWithoutUserCityNestedInput
}

export type UserCityUncheckedUpdateInput = {
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  cityId?: Prisma.StringFieldUpdateOperationsInput | string
  role?: Prisma.EnumUserCityRoleFieldUpdateOperationsInput | $Enums.UserCityRole
}

export type UserCityCreateManyInput = {
  userId: string
  cityId: string
  role: $Enums.UserCityRole
}

export type UserCityUpdateManyMutationInput = {
  role?: Prisma.EnumUserCityRoleFieldUpdateOperationsInput | $Enums.UserCityRole
}

export type UserCityUncheckedUpdateManyInput = {
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  cityId?: Prisma.StringFieldUpdateOperationsInput | string
  role?: Prisma.EnumUserCityRoleFieldUpdateOperationsInput | $Enums.UserCityRole
}

export type UserCityListRelationFilter = {
  every?: Prisma.UserCityWhereInput
  some?: Prisma.UserCityWhereInput
  none?: Prisma.UserCityWhereInput
}

export type UserCityOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type UserCityOrderByRelevanceInput = {
  fields: Prisma.UserCityOrderByRelevanceFieldEnum | Prisma.UserCityOrderByRelevanceFieldEnum[]
  sort: Prisma.SortOrder
  search: string
}

export type UserCityUserIdCityIdCompoundUniqueInput = {
  userId: string
  cityId: string
}

export type UserCityCountOrderByAggregateInput = {
  userId?: Prisma.SortOrder
  cityId?: Prisma.SortOrder
  role?: Prisma.SortOrder
}

export type UserCityMaxOrderByAggregateInput = {
  userId?: Prisma.SortOrder
  cityId?: Prisma.SortOrder
  role?: Prisma.SortOrder
}

export type UserCityMinOrderByAggregateInput = {
  userId?: Prisma.SortOrder
  cityId?: Prisma.SortOrder
  role?: Prisma.SortOrder
}

export type UserCityCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.UserCityCreateWithoutUserInput, Prisma.UserCityUncheckedCreateWithoutUserInput> | Prisma.UserCityCreateWithoutUserInput[] | Prisma.UserCityUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.UserCityCreateOrConnectWithoutUserInput | Prisma.UserCityCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.UserCityCreateManyUserInputEnvelope
  connect?: Prisma.UserCityWhereUniqueInput | Prisma.UserCityWhereUniqueInput[]
}

export type UserCityUncheckedCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.UserCityCreateWithoutUserInput, Prisma.UserCityUncheckedCreateWithoutUserInput> | Prisma.UserCityCreateWithoutUserInput[] | Prisma.UserCityUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.UserCityCreateOrConnectWithoutUserInput | Prisma.UserCityCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.UserCityCreateManyUserInputEnvelope
  connect?: Prisma.UserCityWhereUniqueInput | Prisma.UserCityWhereUniqueInput[]
}

export type UserCityUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.UserCityCreateWithoutUserInput, Prisma.UserCityUncheckedCreateWithoutUserInput> | Prisma.UserCityCreateWithoutUserInput[] | Prisma.UserCityUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.UserCityCreateOrConnectWithoutUserInput | Prisma.UserCityCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.UserCityUpsertWithWhereUniqueWithoutUserInput | Prisma.UserCityUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.UserCityCreateManyUserInputEnvelope
  set?: Prisma.UserCityWhereUniqueInput | Prisma.UserCityWhereUniqueInput[]
  disconnect?: Prisma.UserCityWhereUniqueInput | Prisma.UserCityWhereUniqueInput[]
  delete?: Prisma.UserCityWhereUniqueInput | Prisma.UserCityWhereUniqueInput[]
  connect?: Prisma.UserCityWhereUniqueInput | Prisma.UserCityWhereUniqueInput[]
  update?: Prisma.UserCityUpdateWithWhereUniqueWithoutUserInput | Prisma.UserCityUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.UserCityUpdateManyWithWhereWithoutUserInput | Prisma.UserCityUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.UserCityScalarWhereInput | Prisma.UserCityScalarWhereInput[]
}

export type UserCityUncheckedUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.UserCityCreateWithoutUserInput, Prisma.UserCityUncheckedCreateWithoutUserInput> | Prisma.UserCityCreateWithoutUserInput[] | Prisma.UserCityUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.UserCityCreateOrConnectWithoutUserInput | Prisma.UserCityCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.UserCityUpsertWithWhereUniqueWithoutUserInput | Prisma.UserCityUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.UserCityCreateManyUserInputEnvelope
  set?: Prisma.UserCityWhereUniqueInput | Prisma.UserCityWhereUniqueInput[]
  disconnect?: Prisma.UserCityWhereUniqueInput | Prisma.UserCityWhereUniqueInput[]
  delete?: Prisma.UserCityWhereUniqueInput | Prisma.UserCityWhereUniqueInput[]
  connect?: Prisma.UserCityWhereUniqueInput | Prisma.UserCityWhereUniqueInput[]
  update?: Prisma.UserCityUpdateWithWhereUniqueWithoutUserInput | Prisma.UserCityUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.UserCityUpdateManyWithWhereWithoutUserInput | Prisma.UserCityUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.UserCityScalarWhereInput | Prisma.UserCityScalarWhereInput[]
}

export type EnumUserCityRoleFieldUpdateOperationsInput = {
  set?: $Enums.UserCityRole
}

export type UserCityCreateNestedManyWithoutCityInput = {
  create?: Prisma.XOR<Prisma.UserCityCreateWithoutCityInput, Prisma.UserCityUncheckedCreateWithoutCityInput> | Prisma.UserCityCreateWithoutCityInput[] | Prisma.UserCityUncheckedCreateWithoutCityInput[]
  connectOrCreate?: Prisma.UserCityCreateOrConnectWithoutCityInput | Prisma.UserCityCreateOrConnectWithoutCityInput[]
  createMany?: Prisma.UserCityCreateManyCityInputEnvelope
  connect?: Prisma.UserCityWhereUniqueInput | Prisma.UserCityWhereUniqueInput[]
}

export type UserCityUncheckedCreateNestedManyWithoutCityInput = {
  create?: Prisma.XOR<Prisma.UserCityCreateWithoutCityInput, Prisma.UserCityUncheckedCreateWithoutCityInput> | Prisma.UserCityCreateWithoutCityInput[] | Prisma.UserCityUncheckedCreateWithoutCityInput[]
  connectOrCreate?: Prisma.UserCityCreateOrConnectWithoutCityInput | Prisma.UserCityCreateOrConnectWithoutCityInput[]
  createMany?: Prisma.UserCityCreateManyCityInputEnvelope
  connect?: Prisma.UserCityWhereUniqueInput | Prisma.UserCityWhereUniqueInput[]
}

export type UserCityUpdateManyWithoutCityNestedInput = {
  create?: Prisma.XOR<Prisma.UserCityCreateWithoutCityInput, Prisma.UserCityUncheckedCreateWithoutCityInput> | Prisma.UserCityCreateWithoutCityInput[] | Prisma.UserCityUncheckedCreateWithoutCityInput[]
  connectOrCreate?: Prisma.UserCityCreateOrConnectWithoutCityInput | Prisma.UserCityCreateOrConnectWithoutCityInput[]
  upsert?: Prisma.UserCityUpsertWithWhereUniqueWithoutCityInput | Prisma.UserCityUpsertWithWhereUniqueWithoutCityInput[]
  createMany?: Prisma.UserCityCreateManyCityInputEnvelope
  set?: Prisma.UserCityWhereUniqueInput | Prisma.UserCityWhereUniqueInput[]
  disconnect?: Prisma.UserCityWhereUniqueInput | Prisma.UserCityWhereUniqueInput[]
  delete?: Prisma.UserCityWhereUniqueInput | Prisma.UserCityWhereUniqueInput[]
  connect?: Prisma.UserCityWhereUniqueInput | Prisma.UserCityWhereUniqueInput[]
  update?: Prisma.UserCityUpdateWithWhereUniqueWithoutCityInput | Prisma.UserCityUpdateWithWhereUniqueWithoutCityInput[]
  updateMany?: Prisma.UserCityUpdateManyWithWhereWithoutCityInput | Prisma.UserCityUpdateManyWithWhereWithoutCityInput[]
  deleteMany?: Prisma.UserCityScalarWhereInput | Prisma.UserCityScalarWhereInput[]
}

export type UserCityUncheckedUpdateManyWithoutCityNestedInput = {
  create?: Prisma.XOR<Prisma.UserCityCreateWithoutCityInput, Prisma.UserCityUncheckedCreateWithoutCityInput> | Prisma.UserCityCreateWithoutCityInput[] | Prisma.UserCityUncheckedCreateWithoutCityInput[]
  connectOrCreate?: Prisma.UserCityCreateOrConnectWithoutCityInput | Prisma.UserCityCreateOrConnectWithoutCityInput[]
  upsert?: Prisma.UserCityUpsertWithWhereUniqueWithoutCityInput | Prisma.UserCityUpsertWithWhereUniqueWithoutCityInput[]
  createMany?: Prisma.UserCityCreateManyCityInputEnvelope
  set?: Prisma.UserCityWhereUniqueInput | Prisma.UserCityWhereUniqueInput[]
  disconnect?: Prisma.UserCityWhereUniqueInput | Prisma.UserCityWhereUniqueInput[]
  delete?: Prisma.UserCityWhereUniqueInput | Prisma.UserCityWhereUniqueInput[]
  connect?: Prisma.UserCityWhereUniqueInput | Prisma.UserCityWhereUniqueInput[]
  update?: Prisma.UserCityUpdateWithWhereUniqueWithoutCityInput | Prisma.UserCityUpdateWithWhereUniqueWithoutCityInput[]
  updateMany?: Prisma.UserCityUpdateManyWithWhereWithoutCityInput | Prisma.UserCityUpdateManyWithWhereWithoutCityInput[]
  deleteMany?: Prisma.UserCityScalarWhereInput | Prisma.UserCityScalarWhereInput[]
}

export type UserCityCreateWithoutUserInput = {
  role: $Enums.UserCityRole
  city: Prisma.CityCreateNestedOneWithoutUserCityInput
}

export type UserCityUncheckedCreateWithoutUserInput = {
  cityId: string
  role: $Enums.UserCityRole
}

export type UserCityCreateOrConnectWithoutUserInput = {
  where: Prisma.UserCityWhereUniqueInput
  create: Prisma.XOR<Prisma.UserCityCreateWithoutUserInput, Prisma.UserCityUncheckedCreateWithoutUserInput>
}

export type UserCityCreateManyUserInputEnvelope = {
  data: Prisma.UserCityCreateManyUserInput | Prisma.UserCityCreateManyUserInput[]
  skipDuplicates?: boolean
}

export type UserCityUpsertWithWhereUniqueWithoutUserInput = {
  where: Prisma.UserCityWhereUniqueInput
  update: Prisma.XOR<Prisma.UserCityUpdateWithoutUserInput, Prisma.UserCityUncheckedUpdateWithoutUserInput>
  create: Prisma.XOR<Prisma.UserCityCreateWithoutUserInput, Prisma.UserCityUncheckedCreateWithoutUserInput>
}

export type UserCityUpdateWithWhereUniqueWithoutUserInput = {
  where: Prisma.UserCityWhereUniqueInput
  data: Prisma.XOR<Prisma.UserCityUpdateWithoutUserInput, Prisma.UserCityUncheckedUpdateWithoutUserInput>
}

export type UserCityUpdateManyWithWhereWithoutUserInput = {
  where: Prisma.UserCityScalarWhereInput
  data: Prisma.XOR<Prisma.UserCityUpdateManyMutationInput, Prisma.UserCityUncheckedUpdateManyWithoutUserInput>
}

export type UserCityScalarWhereInput = {
  AND?: Prisma.UserCityScalarWhereInput | Prisma.UserCityScalarWhereInput[]
  OR?: Prisma.UserCityScalarWhereInput[]
  NOT?: Prisma.UserCityScalarWhereInput | Prisma.UserCityScalarWhereInput[]
  userId?: Prisma.StringFilter<"UserCity"> | string
  cityId?: Prisma.StringFilter<"UserCity"> | string
  role?: Prisma.EnumUserCityRoleFilter<"UserCity"> | $Enums.UserCityRole
}

export type UserCityCreateWithoutCityInput = {
  role: $Enums.UserCityRole
  user: Prisma.UserCreateNestedOneWithoutCitiesInput
}

export type UserCityUncheckedCreateWithoutCityInput = {
  userId: string
  role: $Enums.UserCityRole
}

export type UserCityCreateOrConnectWithoutCityInput = {
  where: Prisma.UserCityWhereUniqueInput
  create: Prisma.XOR<Prisma.UserCityCreateWithoutCityInput, Prisma.UserCityUncheckedCreateWithoutCityInput>
}

export type UserCityCreateManyCityInputEnvelope = {
  data: Prisma.UserCityCreateManyCityInput | Prisma.UserCityCreateManyCityInput[]
  skipDuplicates?: boolean
}

export type UserCityUpsertWithWhereUniqueWithoutCityInput = {
  where: Prisma.UserCityWhereUniqueInput
  update: Prisma.XOR<Prisma.UserCityUpdateWithoutCityInput, Prisma.UserCityUncheckedUpdateWithoutCityInput>
  create: Prisma.XOR<Prisma.UserCityCreateWithoutCityInput, Prisma.UserCityUncheckedCreateWithoutCityInput>
}

export type UserCityUpdateWithWhereUniqueWithoutCityInput = {
  where: Prisma.UserCityWhereUniqueInput
  data: Prisma.XOR<Prisma.UserCityUpdateWithoutCityInput, Prisma.UserCityUncheckedUpdateWithoutCityInput>
}

export type UserCityUpdateManyWithWhereWithoutCityInput = {
  where: Prisma.UserCityScalarWhereInput
  data: Prisma.XOR<Prisma.UserCityUpdateManyMutationInput, Prisma.UserCityUncheckedUpdateManyWithoutCityInput>
}

export type UserCityCreateManyUserInput = {
  cityId: string
  role: $Enums.UserCityRole
}

export type UserCityUpdateWithoutUserInput = {
  role?: Prisma.EnumUserCityRoleFieldUpdateOperationsInput | $Enums.UserCityRole
  city?: Prisma.CityUpdateOneRequiredWithoutUserCityNestedInput
}

export type UserCityUncheckedUpdateWithoutUserInput = {
  cityId?: Prisma.StringFieldUpdateOperationsInput | string
  role?: Prisma.EnumUserCityRoleFieldUpdateOperationsInput | $Enums.UserCityRole
}

export type UserCityUncheckedUpdateManyWithoutUserInput = {
  cityId?: Prisma.StringFieldUpdateOperationsInput | string
  role?: Prisma.EnumUserCityRoleFieldUpdateOperationsInput | $Enums.UserCityRole
}

export type UserCityCreateManyCityInput = {
  userId: string
  role: $Enums.UserCityRole
}

export type UserCityUpdateWithoutCityInput = {
  role?: Prisma.EnumUserCityRoleFieldUpdateOperationsInput | $Enums.UserCityRole
  user?: Prisma.UserUpdateOneRequiredWithoutCitiesNestedInput
}

export type UserCityUncheckedUpdateWithoutCityInput = {
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  role?: Prisma.EnumUserCityRoleFieldUpdateOperationsInput | $Enums.UserCityRole
}

export type UserCityUncheckedUpdateManyWithoutCityInput = {
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  role?: Prisma.EnumUserCityRoleFieldUpdateOperationsInput | $Enums.UserCityRole
}



export type UserCitySelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  userId?: boolean
  cityId?: boolean
  role?: boolean
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  city?: boolean | Prisma.CityDefaultArgs<ExtArgs>
}, ExtArgs["result"]["userCity"]>

export type UserCitySelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  userId?: boolean
  cityId?: boolean
  role?: boolean
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  city?: boolean | Prisma.CityDefaultArgs<ExtArgs>
}, ExtArgs["result"]["userCity"]>

export type UserCitySelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  userId?: boolean
  cityId?: boolean
  role?: boolean
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  city?: boolean | Prisma.CityDefaultArgs<ExtArgs>
}, ExtArgs["result"]["userCity"]>

export type UserCitySelectScalar = {
  userId?: boolean
  cityId?: boolean
  role?: boolean
}

export type UserCityOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"userId" | "cityId" | "role", ExtArgs["result"]["userCity"]>
export type UserCityInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  city?: boolean | Prisma.CityDefaultArgs<ExtArgs>
}
export type UserCityIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  city?: boolean | Prisma.CityDefaultArgs<ExtArgs>
}
export type UserCityIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  city?: boolean | Prisma.CityDefaultArgs<ExtArgs>
}

export type $UserCityPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "UserCity"
  objects: {
    user: Prisma.$UserPayload<ExtArgs>
    city: Prisma.$CityPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    userId: string
    cityId: string
    role: $Enums.UserCityRole
  }, ExtArgs["result"]["userCity"]>
  composites: {}
}

export type UserCityGetPayload<S extends boolean | null | undefined | UserCityDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$UserCityPayload, S>

export type UserCityCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<UserCityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: UserCityCountAggregateInputType | true
  }

export interface UserCityDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserCity'], meta: { name: 'UserCity' } }
  /**
   * Find zero or one UserCity that matches the filter.
   * @param {UserCityFindUniqueArgs} args - Arguments to find a UserCity
   * @example
   * // Get one UserCity
   * const userCity = await prisma.userCity.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends UserCityFindUniqueArgs>(args: Prisma.SelectSubset<T, UserCityFindUniqueArgs<ExtArgs>>): Prisma.Prisma__UserCityClient<runtime.Types.Result.GetResult<Prisma.$UserCityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one UserCity that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {UserCityFindUniqueOrThrowArgs} args - Arguments to find a UserCity
   * @example
   * // Get one UserCity
   * const userCity = await prisma.userCity.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends UserCityFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, UserCityFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__UserCityClient<runtime.Types.Result.GetResult<Prisma.$UserCityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first UserCity that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {UserCityFindFirstArgs} args - Arguments to find a UserCity
   * @example
   * // Get one UserCity
   * const userCity = await prisma.userCity.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends UserCityFindFirstArgs>(args?: Prisma.SelectSubset<T, UserCityFindFirstArgs<ExtArgs>>): Prisma.Prisma__UserCityClient<runtime.Types.Result.GetResult<Prisma.$UserCityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first UserCity that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {UserCityFindFirstOrThrowArgs} args - Arguments to find a UserCity
   * @example
   * // Get one UserCity
   * const userCity = await prisma.userCity.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends UserCityFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, UserCityFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__UserCityClient<runtime.Types.Result.GetResult<Prisma.$UserCityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more UserCities that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {UserCityFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all UserCities
   * const userCities = await prisma.userCity.findMany()
   * 
   * // Get first 10 UserCities
   * const userCities = await prisma.userCity.findMany({ take: 10 })
   * 
   * // Only select the `userId`
   * const userCityWithUserIdOnly = await prisma.userCity.findMany({ select: { userId: true } })
   * 
   */
  findMany<T extends UserCityFindManyArgs>(args?: Prisma.SelectSubset<T, UserCityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$UserCityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a UserCity.
   * @param {UserCityCreateArgs} args - Arguments to create a UserCity.
   * @example
   * // Create one UserCity
   * const UserCity = await prisma.userCity.create({
   *   data: {
   *     // ... data to create a UserCity
   *   }
   * })
   * 
   */
  create<T extends UserCityCreateArgs>(args: Prisma.SelectSubset<T, UserCityCreateArgs<ExtArgs>>): Prisma.Prisma__UserCityClient<runtime.Types.Result.GetResult<Prisma.$UserCityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many UserCities.
   * @param {UserCityCreateManyArgs} args - Arguments to create many UserCities.
   * @example
   * // Create many UserCities
   * const userCity = await prisma.userCity.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends UserCityCreateManyArgs>(args?: Prisma.SelectSubset<T, UserCityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many UserCities and returns the data saved in the database.
   * @param {UserCityCreateManyAndReturnArgs} args - Arguments to create many UserCities.
   * @example
   * // Create many UserCities
   * const userCity = await prisma.userCity.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many UserCities and only return the `userId`
   * const userCityWithUserIdOnly = await prisma.userCity.createManyAndReturn({
   *   select: { userId: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends UserCityCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, UserCityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$UserCityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a UserCity.
   * @param {UserCityDeleteArgs} args - Arguments to delete one UserCity.
   * @example
   * // Delete one UserCity
   * const UserCity = await prisma.userCity.delete({
   *   where: {
   *     // ... filter to delete one UserCity
   *   }
   * })
   * 
   */
  delete<T extends UserCityDeleteArgs>(args: Prisma.SelectSubset<T, UserCityDeleteArgs<ExtArgs>>): Prisma.Prisma__UserCityClient<runtime.Types.Result.GetResult<Prisma.$UserCityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one UserCity.
   * @param {UserCityUpdateArgs} args - Arguments to update one UserCity.
   * @example
   * // Update one UserCity
   * const userCity = await prisma.userCity.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends UserCityUpdateArgs>(args: Prisma.SelectSubset<T, UserCityUpdateArgs<ExtArgs>>): Prisma.Prisma__UserCityClient<runtime.Types.Result.GetResult<Prisma.$UserCityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more UserCities.
   * @param {UserCityDeleteManyArgs} args - Arguments to filter UserCities to delete.
   * @example
   * // Delete a few UserCities
   * const { count } = await prisma.userCity.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends UserCityDeleteManyArgs>(args?: Prisma.SelectSubset<T, UserCityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more UserCities.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {UserCityUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many UserCities
   * const userCity = await prisma.userCity.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends UserCityUpdateManyArgs>(args: Prisma.SelectSubset<T, UserCityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more UserCities and returns the data updated in the database.
   * @param {UserCityUpdateManyAndReturnArgs} args - Arguments to update many UserCities.
   * @example
   * // Update many UserCities
   * const userCity = await prisma.userCity.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more UserCities and only return the `userId`
   * const userCityWithUserIdOnly = await prisma.userCity.updateManyAndReturn({
   *   select: { userId: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends UserCityUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, UserCityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$UserCityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one UserCity.
   * @param {UserCityUpsertArgs} args - Arguments to update or create a UserCity.
   * @example
   * // Update or create a UserCity
   * const userCity = await prisma.userCity.upsert({
   *   create: {
   *     // ... data to create a UserCity
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the UserCity we want to update
   *   }
   * })
   */
  upsert<T extends UserCityUpsertArgs>(args: Prisma.SelectSubset<T, UserCityUpsertArgs<ExtArgs>>): Prisma.Prisma__UserCityClient<runtime.Types.Result.GetResult<Prisma.$UserCityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of UserCities.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {UserCityCountArgs} args - Arguments to filter UserCities to count.
   * @example
   * // Count the number of UserCities
   * const count = await prisma.userCity.count({
   *   where: {
   *     // ... the filter for the UserCities we want to count
   *   }
   * })
  **/
  count<T extends UserCityCountArgs>(
    args?: Prisma.Subset<T, UserCityCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], UserCityCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a UserCity.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {UserCityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends UserCityAggregateArgs>(args: Prisma.Subset<T, UserCityAggregateArgs>): Prisma.PrismaPromise<GetUserCityAggregateType<T>>

  /**
   * Group by UserCity.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {UserCityGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends UserCityGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: UserCityGroupByArgs['orderBy'] }
      : { orderBy?: UserCityGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, UserCityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserCityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the UserCity model
 */
readonly fields: UserCityFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for UserCity.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__UserCityClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  user<T extends Prisma.UserDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.UserDefaultArgs<ExtArgs>>): Prisma.Prisma__UserClient<runtime.Types.Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  city<T extends Prisma.CityDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.CityDefaultArgs<ExtArgs>>): Prisma.Prisma__CityClient<runtime.Types.Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the UserCity model
 */
export interface UserCityFieldRefs {
  readonly userId: Prisma.FieldRef<"UserCity", 'String'>
  readonly cityId: Prisma.FieldRef<"UserCity", 'String'>
  readonly role: Prisma.FieldRef<"UserCity", 'UserCityRole'>
}
    

// Custom InputTypes
/**
 * UserCity findUnique
 */
export type UserCityFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserCity
   */
  select?: Prisma.UserCitySelect<ExtArgs> | null
  /**
   * Omit specific fields from the UserCity
   */
  omit?: Prisma.UserCityOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserCityInclude<ExtArgs> | null
  /**
   * Filter, which UserCity to fetch.
   */
  where: Prisma.UserCityWhereUniqueInput
}

/**
 * UserCity findUniqueOrThrow
 */
export type UserCityFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserCity
   */
  select?: Prisma.UserCitySelect<ExtArgs> | null
  /**
   * Omit specific fields from the UserCity
   */
  omit?: Prisma.UserCityOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserCityInclude<ExtArgs> | null
  /**
   * Filter, which UserCity to fetch.
   */
  where: Prisma.UserCityWhereUniqueInput
}

/**
 * UserCity findFirst
 */
export type UserCityFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserCity
   */
  select?: Prisma.UserCitySelect<ExtArgs> | null
  /**
   * Omit specific fields from the UserCity
   */
  omit?: Prisma.UserCityOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserCityInclude<ExtArgs> | null
  /**
   * Filter, which UserCity to fetch.
   */
  where?: Prisma.UserCityWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of UserCities to fetch.
   */
  orderBy?: Prisma.UserCityOrderByWithRelationInput | Prisma.UserCityOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for UserCities.
   */
  cursor?: Prisma.UserCityWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` UserCities from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` UserCities.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of UserCities.
   */
  distinct?: Prisma.UserCityScalarFieldEnum | Prisma.UserCityScalarFieldEnum[]
}

/**
 * UserCity findFirstOrThrow
 */
export type UserCityFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserCity
   */
  select?: Prisma.UserCitySelect<ExtArgs> | null
  /**
   * Omit specific fields from the UserCity
   */
  omit?: Prisma.UserCityOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserCityInclude<ExtArgs> | null
  /**
   * Filter, which UserCity to fetch.
   */
  where?: Prisma.UserCityWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of UserCities to fetch.
   */
  orderBy?: Prisma.UserCityOrderByWithRelationInput | Prisma.UserCityOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for UserCities.
   */
  cursor?: Prisma.UserCityWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` UserCities from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` UserCities.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of UserCities.
   */
  distinct?: Prisma.UserCityScalarFieldEnum | Prisma.UserCityScalarFieldEnum[]
}

/**
 * UserCity findMany
 */
export type UserCityFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserCity
   */
  select?: Prisma.UserCitySelect<ExtArgs> | null
  /**
   * Omit specific fields from the UserCity
   */
  omit?: Prisma.UserCityOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserCityInclude<ExtArgs> | null
  /**
   * Filter, which UserCities to fetch.
   */
  where?: Prisma.UserCityWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of UserCities to fetch.
   */
  orderBy?: Prisma.UserCityOrderByWithRelationInput | Prisma.UserCityOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing UserCities.
   */
  cursor?: Prisma.UserCityWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` UserCities from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` UserCities.
   */
  skip?: number
  distinct?: Prisma.UserCityScalarFieldEnum | Prisma.UserCityScalarFieldEnum[]
}

/**
 * UserCity create
 */
export type UserCityCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserCity
   */
  select?: Prisma.UserCitySelect<ExtArgs> | null
  /**
   * Omit specific fields from the UserCity
   */
  omit?: Prisma.UserCityOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserCityInclude<ExtArgs> | null
  /**
   * The data needed to create a UserCity.
   */
  data: Prisma.XOR<Prisma.UserCityCreateInput, Prisma.UserCityUncheckedCreateInput>
}

/**
 * UserCity createMany
 */
export type UserCityCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many UserCities.
   */
  data: Prisma.UserCityCreateManyInput | Prisma.UserCityCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * UserCity createManyAndReturn
 */
export type UserCityCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserCity
   */
  select?: Prisma.UserCitySelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the UserCity
   */
  omit?: Prisma.UserCityOmit<ExtArgs> | null
  /**
   * The data used to create many UserCities.
   */
  data: Prisma.UserCityCreateManyInput | Prisma.UserCityCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserCityIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * UserCity update
 */
export type UserCityUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserCity
   */
  select?: Prisma.UserCitySelect<ExtArgs> | null
  /**
   * Omit specific fields from the UserCity
   */
  omit?: Prisma.UserCityOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserCityInclude<ExtArgs> | null
  /**
   * The data needed to update a UserCity.
   */
  data: Prisma.XOR<Prisma.UserCityUpdateInput, Prisma.UserCityUncheckedUpdateInput>
  /**
   * Choose, which UserCity to update.
   */
  where: Prisma.UserCityWhereUniqueInput
}

/**
 * UserCity updateMany
 */
export type UserCityUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update UserCities.
   */
  data: Prisma.XOR<Prisma.UserCityUpdateManyMutationInput, Prisma.UserCityUncheckedUpdateManyInput>
  /**
   * Filter which UserCities to update
   */
  where?: Prisma.UserCityWhereInput
  /**
   * Limit how many UserCities to update.
   */
  limit?: number
}

/**
 * UserCity updateManyAndReturn
 */
export type UserCityUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserCity
   */
  select?: Prisma.UserCitySelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the UserCity
   */
  omit?: Prisma.UserCityOmit<ExtArgs> | null
  /**
   * The data used to update UserCities.
   */
  data: Prisma.XOR<Prisma.UserCityUpdateManyMutationInput, Prisma.UserCityUncheckedUpdateManyInput>
  /**
   * Filter which UserCities to update
   */
  where?: Prisma.UserCityWhereInput
  /**
   * Limit how many UserCities to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserCityIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * UserCity upsert
 */
export type UserCityUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserCity
   */
  select?: Prisma.UserCitySelect<ExtArgs> | null
  /**
   * Omit specific fields from the UserCity
   */
  omit?: Prisma.UserCityOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserCityInclude<ExtArgs> | null
  /**
   * The filter to search for the UserCity to update in case it exists.
   */
  where: Prisma.UserCityWhereUniqueInput
  /**
   * In case the UserCity found by the `where` argument doesn't exist, create a new UserCity with this data.
   */
  create: Prisma.XOR<Prisma.UserCityCreateInput, Prisma.UserCityUncheckedCreateInput>
  /**
   * In case the UserCity was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.UserCityUpdateInput, Prisma.UserCityUncheckedUpdateInput>
}

/**
 * UserCity delete
 */
export type UserCityDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserCity
   */
  select?: Prisma.UserCitySelect<ExtArgs> | null
  /**
   * Omit specific fields from the UserCity
   */
  omit?: Prisma.UserCityOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserCityInclude<ExtArgs> | null
  /**
   * Filter which UserCity to delete.
   */
  where: Prisma.UserCityWhereUniqueInput
}

/**
 * UserCity deleteMany
 */
export type UserCityDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which UserCities to delete
   */
  where?: Prisma.UserCityWhereInput
  /**
   * Limit how many UserCities to delete.
   */
  limit?: number
}

/**
 * UserCity without action
 */
export type UserCityDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserCity
   */
  select?: Prisma.UserCitySelect<ExtArgs> | null
  /**
   * Omit specific fields from the UserCity
   */
  omit?: Prisma.UserCityOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserCityInclude<ExtArgs> | null
}
